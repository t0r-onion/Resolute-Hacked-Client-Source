package vip.Resolute.modules.impl.exploit;

import net.minecraft.network.Packet;
import net.minecraft.network.play.server.S08PacketPlayerPosLook;
import vip.Resolute.events.Event;
import vip.Resolute.events.impl.EventMotion;
import vip.Resolute.events.impl.EventMove;
import vip.Resolute.events.impl.EventPacket;
import vip.Resolute.modules.Module;
import vip.Resolute.settings.impl.ModeSetting;
import vip.Resolute.settings.impl.NumberSetting;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.util.AxisAlignedBB;

import java.util.ArrayList;
import java.util.List;

public class AntiVoid extends Module {
    public ModeSetting mode = new ModeSetting("Mode", "Watchdog", "Vanilla", "Watchdog", "Position", "Jump", "Bounce", "Jartex");

    public NumberSetting distance = new NumberSetting("Distance", 6.0, 4.0, 15.0, 1.0);
    public NumberSetting bounceHeight = new NumberSetting("Bounce Height", 1.1, this::isModeSelected, 0.1, 5.0, 0.1);

    double oldy;
    double oldx;
    double oldz;

    private boolean needJump = false;
    private double lastY = 0;
    private double x, y, z;
    private boolean falling;
    private List<Packet> packets = new ArrayList<>();

    private boolean canSpoof=false;
    private double lastRecY=0.0;

    public boolean isModeSelected() {
        return this.mode.is("Bounce");
    }

    public AntiVoid() {
        super("AntiFall", 0, "Lags you out of the void", Category.EXPLOIT);
        this.addSettings(mode, distance, bounceHeight);
    }

    public void onEvent(Event e) {
        if(e instanceof EventMove) {
            EventMove event = (EventMove) e;

            if(mode.is("Bounce")) {
                if (mc.thePlayer.fallDistance >= distance.getValue() && mc.thePlayer.motionY <= 0 && (!needJump || mc.thePlayer.posY <= lastY) && mc.theWorld.getCollidingBoundingBoxes(mc.thePlayer, mc.thePlayer.getEntityBoundingBox().offset(0, 0, 0).expand(0, 0, 0)).isEmpty() && mc.theWorld.getCollidingBoundingBoxes(mc.thePlayer, mc.thePlayer.getEntityBoundingBox().offset(0, -10002.25, 0).expand(0, -10003.75, 0)).isEmpty()){
                    mc.thePlayer.motionY = bounceHeight.getValue();
                    event.setX(0);
                    event.setZ(0);
                    lastY = mc.thePlayer.posY;
                    needJump = true;
                }

                if (mc.thePlayer.onGround) {
                    lastY = 0;
                    needJump = false;
                }
            }
        }

        if(e instanceof EventMotion) {
            EventMotion event = (EventMotion) e;

            if(mode.is("Vanilla")) {
                if (this.mc.thePlayer.onGround) {
                    this.oldx = this.mc.thePlayer.posX;
                    this.oldy = this.mc.thePlayer.posY;
                    this.oldz = this.mc.thePlayer.posZ;
                } else if(mc.thePlayer.fallDistance >= distance.getValue() && mc.thePlayer.ticksExisted % 5 == 0 && !isBlockUnder()) {
                    this.mc.thePlayer.setPosition(this.oldx, this.oldy, this.oldz);
                }
            }

            if(mode.is("Jartex")) {
                canSpoof=false;
                if(mc.theWorld.getCollidingBoundingBoxes(mc.thePlayer, mc.thePlayer.getEntityBoundingBox().offset(
                        0.0, 0.0, 0.0
                ).expand(0.0, 0.0, 0.0)).isEmpty() && mc.theWorld.getCollidingBoundingBoxes(mc.thePlayer, mc.thePlayer.getEntityBoundingBox().offset(
                        0.0, -282.25, 0.0
                ).expand(0.0, -283.75, 0.0)).isEmpty()) {
                    if(mc.thePlayer.fallDistance>distance.getValue() && mc.thePlayer.posY<lastRecY+0.01 && mc.thePlayer.motionY<=0 && !mc.thePlayer.onGround){
                        mc.thePlayer.motionY=0.0;
                        mc.thePlayer.motionZ*=0.838;
                        mc.thePlayer.motionX*=0.838;
                        canSpoof=true;
                    }else if(mc.thePlayer.posY>lastRecY+0.01) mc.thePlayer.fallDistance = 0.0f;
                }
                lastRecY = mc.thePlayer.posY;
            }

            if(e.isPre()) {
                if(mode.is("Blink")) {
                    if (isBlockUnder() && mc.thePlayer.isCollidedVertically && mc.thePlayer.onGround) {
                        x = mc.thePlayer.posX;
                        y = mc.thePlayer.posY;
                        z = mc.thePlayer.posZ;
                    }
                    if (falling && mc.thePlayer.fallDistance > distance.getValue()) {
                        packets.clear();
                        mc.thePlayer.setPositionAndUpdate(x, y, z);
                        event.setX(x);
                        event.setY(y);
                        event.setZ(z);
                    }
                }
            }

            if(mode.is("Position")) {
                if(mc.thePlayer.fallDistance >= distance.getValue() && !isBlockUnder()) {
                    mc.thePlayer.setPosition(mc.thePlayer.posX, mc.thePlayer.posY + 1, mc.thePlayer.posZ);
                }
            }

            if(mode.is("Jump")) {
                if(mc.thePlayer.fallDistance >= distance.getValue() && !isBlockUnder()) {
                    mc.thePlayer.jump();
                }
            }

            if(mode.is("Watchdog")) {
                if(mc.thePlayer.fallDistance >= distance.getValue() && !isBlockUnder()) {
                    mc.getNetHandler().getNetworkManager().sendPacket(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY + 12, mc.thePlayer.posZ, false));
                    mc.thePlayer.fallDistance = 0;
                }
            }
        }

        if(e instanceof EventPacket) {
            if(mode.is("Jartex")) {
                if (canSpoof && (((EventPacket) e).getPacket() instanceof C03PacketPlayer)) {
                    C03PacketPlayer packetPlayer = ((EventPacket) e).getPacket();
                    packetPlayer.onGround = true;
                }
            }

            if(mode.is("Blink")) {
                if(((EventPacket) e).getPacket() instanceof C03PacketPlayer) {
                    C03PacketPlayer cpacket = ((EventPacket) e).getPacket();

                    if (!isBlockUnder()) {
                        packets.add(cpacket);
                        e.setCancelled(true);
                        falling = true;
                    } else {
                        if (mc.thePlayer.fallDistance < distance.getValue()) {
                            if (falling) {
                                try {
                                    for (Packet packet : packets)
                                        mc.getNetHandler().getNetworkManager().sendPacket(packet);
                                } catch (Exception ex) {
                                    ex.printStackTrace();
                                }

                                packets.clear();
                                falling = false;
                            }
                        }
                    }
                }

                if(((EventPacket) e).getPacket() instanceof S08PacketPlayerPosLook) {
                    S08PacketPlayerPosLook posLook = ((EventPacket) e).getPacket();
                    for (Packet packet : packets) {
                        C03PacketPlayer packetPlayer = (C03PacketPlayer) packet;
                        if (packetPlayer.getPositionX() == posLook.getX() && packetPlayer.getPositionY() == posLook.getY() && packetPlayer.getPositionZ() == posLook.getZ()) {
                            packets.clear();
                            falling = false;
                        }
                    }
                }
            }
        }
    }
    public static boolean isBlockUnder() {
        for (int offset = 0; offset < mc.thePlayer.posY + mc.thePlayer.getEyeHeight(); offset += 2) {
            AxisAlignedBB boundingBox = mc.thePlayer.getEntityBoundingBox().offset(0, -offset, 0);

            if (!mc.theWorld.getCollidingBoundingBoxes(mc.thePlayer, boundingBox).isEmpty())
                return true;
        }
        return false;
    }

}
